# concept

이 문서는 이 언어가 어떠한 방식으로 동작하도록 만들어졌는지를 설명합니다.

## 2.1 Anchor
---

[1. Tutorial] 에서는 `take-move(1, 0);`처럼 세미콜론( `;` )으로 끝나는 한 줄의 코드를 사용했습니다. "시작하기"에서는 이것을 "하나의 독립된 설명"이라고 불렀습니다.

세미콜론( `;` )으로 구분되는 하나의 블록을 **식 연쇄**라고 부릅니다.

식 연쇄가 중요한 이유는, 연쇄 내부에서는 '기준 위치'가 계속 이동하기 때문입니다.

### 기준 위치(Anchor)

- '기준 위치'는 행마를 계산하기 시작하는 **출발점**입니다. 현재 기물이 있는 칸을 나타내는 🌟 이모지로 표현해 봅시다.
- '식 연쇄'가 처음 시작될 때, '기준 위치'는 🌟 현재 기물이 있는 칸입니다.
- `move(1, 0)`과 같은 '행마식'이 실행되면, '기준 위치' 🌟는 (1, 0)만큼 이동합니다.
- 세미콜론( `;` )을 만나 '식 연쇄'가 끝나면, '기준 위치' 🌟는 다음 연쇄를 위해 다시 "현재 기물이 있는 칸"으로 초기화됩니다.

이 차이를 보여주는 두 가지 예시가 있습니다.

### 예시: 하나의 '식 연쇄' (중간 지점 포함 2칸 활성화)

`move(1, 0) move(1, 0);`

이 행마법은 다음과 같이 해석됩니다. (기물이 `[c2]`에 있다고 가정해 봅시다.)

**초기 상태:** '기준 위치' 🌟는 기물 ♟️과 함께 `[c2]`에 있습니다.

|  |  |  |  |  |
| --- | --- | --- | --- | --- |
|  |  | ♟️🌟 |  |  |
|  |  |  |  |  |
1. 첫 번째 식 `move(1, 0)` 실행:
    - 행동 1 (활성화): 현재 '기준 위치' (🌟, `[c2]`)에서 (1, 0) 칸 (즉, `[d2]`)을 활성화합니다.
    - 기물을 클릭란 후 활성화된 칸을 클릭하거나, 기물을 끌어서 활성화된 칸 위에 놓는다면 기물이 해당 위치로 이동합니다.
        
        
        |  |  |  |  |  |
        | --- | --- | --- | --- | --- |
        |  |  | ♟️🌟 | 🔵 |  |
        |  |  |  |  |  |
    - 행동 2 (이동): '기준 위치' 🌟가 `[d2]`로 이동합니다.
        
        
        |  |  |  |  |  |
        | --- | --- | --- | --- | --- |
        |  |  | ♟️ | 🔵🌟 |  |
        |  |  |  |  |  |
    - 만약 `move(1, 0) move(1, 0);` 대신 `move(1, 0); move(1, 0);`이 입력된다면, 위 과정만 2번 실행되어 결과적으로 `move(1, 0);` 한 번만 입력한 것과 동일한 행마법이 표현됩니다.
2. 두 번째 식 `move(1, 0)` 실행:
    - 행동 1 (활성화): 새로운 '기준 위치' (🌟, `[d2]`)에서 (1, 0) 칸 (즉, `[e2]`)을 활성화합니다.
        
        
        |  |  |  |  |  |
        | --- | --- | --- | --- | --- |
        |  |  | ♟️ | 🔵🌟 | 🔵 |
        |  |  |  |  |  |
    - 행동 2 (이동): '기준 위치' 🌟가 `[e2]`로 이동합니다.
        
        
        |  |  |  |  |  |
        | --- | --- | --- | --- | --- |
        |  |  | ♟️ | 🔵 | 🔵🌟 |
        |  |  |  |  |  |
    - 세미콜론( `;` )을 만나 연쇄가 종료됩니다.

---

**최종 결과**

|  |  |  |  |  |
| --- | --- | --- | --- | --- |
|  |  | ♟️ | 🔵 | 🔵 |
|  |  |  |  |  |

`[d2]`와 `[e2]` (즉, (1, 0)과 (2, 0)) 두 칸이 모두 활성화됩니다.

### `anchor`식

`anchor`식으로 기준 위치(anchor)를 직접 조작할 수 있습니다. `anchor(dx, dy)`는 기준 위치를 가로로 `dx`, 세로로 `dy`만큼 옮겨 줍니다.

## 2.2 Termination

---

[2.1 Anchor]  에서 '행마식'(`move` 등)이 칸을 활성화하고 '기준 위치'를 옮긴다는 것을 배웠습니다.

하지만 '행마식'은 한 가지 일을 더 합니다. 바로 실행 후 자신의 상태를 보고합니다.

- **성공 (`true`):** 계획대로 칸을 활성화(혹은 이동)했고, 다음 식을 계속 진행해도 좋습니다.
- **실패 (`false`):** 벽, 아군, 또는 규칙(예: `move`가 적을 만남)에 막혀 아무것도 못 했습니다. 멈춰야 합니다.

### 식 연쇄의 생명 규칙

> 하나의 식 연쇄 안에서, 일반 식이 false 값을 보고받으면, 해당 식 연쇄의 실행이 중단됩니다.
> 

(일반 식이란 `jmp`, `not` 등 특별한 제어식을 제외한 대부분의 식을 의미합니다.)

---

### 튜토리얼 룩(Rook)의 비밀

튜토리얼에서 `take-move(1, 0) repeat(1);`이 벽이나 기물을 만나면 "알아서" 멈췄던 이유가 바로 이 규칙 때문입니다.

`take-move` 식은 이렇게 "상태"를 보고합니다.

`take-move`는 적을 잡는 칸(마지막 칸)을 활성화한 뒤 `false`를 보고하여 "임무 완수, 연쇄 중단"을 알립니다.

| take-move가 만난 대상 | 칸 활성화 | 위치 이동 | 값 |
| --- | --- | --- | --- |
| 빈 칸 | 함 | 함 | `true` |
| 적 기물 | 함 | 함 | `false` |
| 아군/벽 | 안 함 | 안 함 | `false` |

---

### 룩(Rook) 예시의 시각화

take-move(1, 0) repeat(1);을 다시 살펴보겠습니다.

기물 ♟️은 [c2]에, 아군 ⚪은 [f2]에 있습니다.

|  |  |  |  |  |
| --- | --- | --- | --- | --- |
|  | ♟️ |  |  | ⚪️ |
|  |  |  |  |  |

1. `[c2]` -> `[d2]` (빈 칸)

- `take-move(1, 0)` 실행: `[d2]` 활성화 🔵, 🌟 `[d2]`로 이동.
    
    
    |  |  |  |  |  |
    | --- | --- | --- | --- | --- |
    |  | ♟️ | 🔵🌟  |  | ⚪️ |
    |  |  |  |  |  |
- 값: ✅ `true`
- `repeat(1)` 실행: ✅ `true` 값을 확인하고, "이전 식(1칸 뒤)"인 `take-move`로 돌아갑니다.

2. `[d2]` -> `[e2]` (빈 칸)

- `take-move(1, 0)` 실행: `[e2]` 활성화 🔵, 🌟 `[e2]`로 이동.
    
    
    |  |  |  |  |  |
    | --- | --- | --- | --- | --- |
    |  | ♟️ | 🔵  | 🔵🌟  | ⚪️ |
    |  |  |  |  |  |
- 값: `true`
- `repeat(1)` 실행: ✅ `true` 값을 확인하고, `take-move`로 돌아갑니다.

3. `[e2]` -> `[f2]` (아군 만남)

- 아무것도 하지 않습니다.
- `take-move(1, 0)` 실행: 🌟 `[e2]` 기준 (1,0)은 `[f2]`입니다. 아군입니다.
- "상태" 보고: `false`
- `repeat(1)` 실행: `false` 값을 확인하고, 돌아가지(반복하지) 않습니다.
- `repeat(1)` 자체도 `false`를 보고받았으므로, '식 연쇄'가 종료됩니다.

**최종 결과**

|  |  |  |  |  |
| --- | --- | --- | --- | --- |
|  | ♟️ | 🔵  | 🔵  | ⚪️ |
|  |  |  |  |  |

## 2.3 Scope

### `{ }` 블록의 두 가지 핵심 규칙

`{ }` 블록은 식 연쇄 안에 작은 주머니를 만드는 것과 같습니다. 이 주머니는 두 가지 규칙을 가집니다.

> `{` 와 `}` 자체도 식이기 때문에, 앞뒤의 다른 표현과 띄어 써야 합니다. `move(1, 0) {move(1,0)};` 은 틀린 식 연쇄이고, `move(1, 0) { move(1,0) };` 처럼 써야 합니다.
> 

### 1. 종료의 격리 (Failure Isolation)

> `{ }` 블록 안에서 식이 ❌ false를 보고하더라도, 식 연쇄 전체가 종료되지 않습니다.
> 
> 
> 대신, 해당 `{ }` 블록의 실행만 즉시 중단되고, 실행 순서는 닫는 괄호 `}` 바로 다음 식으로 점프합니다.
> 

### 2. '기준 위치'의 복원 (Anchor Scoping)

> `{ }` 블록은 시작할 때(`{`)의 기준 위치 🌟를 체크포인트처럼 저장해 둡니다.
> 
> 
> 블록 안에서 move 등으로 🌟기준 위치가 아무리 멀리 이동했더라도,
> 
> 블록이 끝나면(`}`), 🌟기준 위치는 저장해둔 체크포인트 위치로 즉시 복원됩니다.
> 

---

### "Y"자 행마 예시 분석

이 두 규칙이 어떻게 "Y"자 행마를 만드는지 시각화해 봅시다.

```coffeescript
move(0, 1) { move(1, 1) } move(-1, 1);
```

**초기 상태:** 🌟 `[c2]`

|  |  |  |  |  |
| --- | --- | --- | --- | --- |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  | ♟️🌟 |  |  |
|  |  |  |  |  |

**1. `move(0, 1)` 실행:**

- `[c3]` 활성화 🔵, 🌟 `[c3]`로 이동.
    
    
    |  |  |  |  |  |
    | --- | --- | --- | --- | --- |
    |  |  |  |  |  |
    |  |  | 🔵🌟 |  |  |
    |  |  | ♟️ |  |  |
    |  |  |  |  |  |

**2. `{` 실행:**

- **체크포인트 설정!** 현재 🌟기준 위치(`[c3]`)를 기억합니다.

**3. `move(1, 1)` (블록 내부) 실행:**

- 현재 🌟(`[c3]`) 기준 (1, 1)인 `[d4]` 활성화 🔵.
- 🌟 `[d4]`로 이동.
    
    
    |  |  |  |  |  |
    | --- | --- | --- | --- | --- |
    |  |  |  | 🔵🌟 |  |
    |  |  | 🔵(🌟) |  |  |
    |  |  | ♟️ |  |  |
    |  |  |  |  |  |

**4. `}` 실행:**

- 블록 종료!
- **체크포인트 `[c3]`로 기준 위치를 복원합니다.**
    
    
    |  |  |  |  |  |
    | --- | --- | --- | --- | --- |
    |  |  |  | 🔵 |  |
    |  |  | 🔵🌟 |  |  |
    |  |  | ♟️ |  |  |
    |  |  |  |  |  |

**5. `move(-1, 1)` 실행:**

- **복원된 🌟기준 위치(`[c3]`)** 기준 (-1, 1)인 `[b4]` 활성화 🔵.
- 🌟 `[b4]`로 이동. (연쇄 종료)
    
    
    |  |  |  |  |  |
    | --- | --- | --- | --- | --- |
    |  | 🔵🌟 |  | 🔵 |  |
    |  |  | 🔵(🌟) |  |  |
    |  |  | ♟️ |  |  |
    |  |  |  |  |  |

**최종 결과:** `[c3]` (줄기), `[d4]` (가지1), `[b4]` (가지2)가 활성화되어 "Y"자 행마가 완성됩니다.

|  |  |  |  |  |
| --- | --- | --- | --- | --- |
|  | 🔵 |  | 🔵 |  |
|  |  | 🔵 |  |  |
|  |  | ♟️ |  |  |
|  |  |  |  |  |

## Tempest-Rook 행마 분석

---

https://youtube.com/shorts/N6MZZPP8cWo?si=CTTF9uShUuzV7fwS

`Tempest-Rook` 예시는 에서 배운 `{ }` 블록의 규칙, 특히 기준 위치 복원(Anchor Scoping)이 어떻게 작동하는지 보여주는 예제입니다.

```less
take-move(1, 1) { take-move(1, 0) repeat(1) } { take-move(0, 1) repeat(1) };
take-move(-1, 1) { take-move(-1, 0) repeat(1) } { take-move(0, 1) repeat(1) };
take-move(1, -1) { take-move(1, 0) repeat(1) } { take-move(0, -1) repeat(1) };
take-move(-1, -1) { take-move(-1, 0) repeat(1) } { take-move(0, -1) repeat(1) };
```

4줄의 코드는 사실상 4개의 독립된 식 연쇄이며, 모두 비슷한 원리로 작동합니다. 첫 번째 줄만 자세히 분석해 보겠습니다.

```less
take-move(1, 1) { take-move(1, 0) repeat(1) } { take-move(0, 1) repeat(1) };
```

이 식 연쇄를 기물(♟️)이 `[c2]`에 있다고 가정하고 시각화해 보겠습니다.

**초기 상태:** 🌟 '기준 위치'는 기물 위치 `[c2]`입니다.

|  |  |  |  |  |
| --- | --- | --- | --- | --- |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  | ♟️🌟 |  |  |
|  |  |  |  |  |

**1. `take-move(1, 1)` 실행:**

- **행동:** `[c2]` 기준 (1, 1)인 `[d3]`을 활성화 🔵합니다.
- **이동:** 🌟 '기준 위치'가 `[d3]`으로 이동합니다.
    
    
    |  |  |  |  |  |
    | --- | --- | --- | --- | --- |
    |  |  |  |  |  |
    |  |  |  | 🔵🌟 |  |
    |  |  | ♟️ |  |  |
    |  |  |  |  |  |
- 만약 아군 기물이 `d3`을 막고 있다면, 행마법은 설치되지 않고 연쇄가 종료됩니다. 적 기물이 있으면 행마법이 설치되고 연쇄가 끝납니다.

**2. `{` (첫 번째 블록 시작):**

- **체크포인트 설정!** 현재 🌟'기준 위치'(`[d3]`)를 기억합니다.

**3. `take-move(1, 0) repeat(1)` (블록 1 내부) 실행:**

- **행동:** 현재 🌟(`[d3]`) 기준으로 (1, 0) '룩 슬라이드'를 실행합니다.
- `[e3]`🔵, `[f3]`🔵, `[g3]`🔵 ... 등이 (벽이나 기물을 만날 때까지) 활성화됩니다.
- (🌟는 `[e3]`, `[f3]`, ... 로 이동하다가 `false`를 반환하고 블록이 멈춥니다.)
    
    
    |  |  |  |  |  |  |  |  |
    | --- | --- | --- | --- | --- | --- | --- | --- |
    |  |  |  |  |  |  |  |  |
    |  |  |  |  |  |  |  |  |
    |  |  |  | 🔵(🌟) | 🔵 | 🔵 | 🔵 | 🔵🌟 |
    |  |  | ♟️ |  |  |  |  |  |

**4. `}` (첫 번째 블록 종료):**

- **체크포인트 복원:** 🌟기준 위치가 기억해둔 `[d3]`로 복원됩니다.
    
    
    |  |  |  |  |  |
    | --- | --- | --- | --- | --- |
    |  |  |  |  |  |
    |  |  |  |  |  |
    |  |  |  | 🔵🌟 | 🔵 … |
    |  |  | ♟️ |  |  |

**5. `{` (두 번째 블록 시작):**

- **"체크포인트" 설정!** 현재 🌟'기준 위치'(`[d3]`)를 다시 기억합니다.

**6. `take-move(0, 1) repeat(1)` (블록 2 내부) 실행:**

- **행동:** **복원된 🌟(`[d3]`)** 기준으로 (0, 1) '룩 슬라이드'를 실행합니다.
- `[d4]`🔵, `[d5]`🔵, `[d6]`🔵 ... 등이 활성화됩니다.
    
    
    |  |  |  | 🔵… |  |
    | --- | --- | --- | --- | --- |
    |  |  |  | 🔵 |  |
    |  |  |  | 🔵 |  |
    |  |  |  | 🔵(🌟) | 🔵 … |
    |  |  | ♟️ |  |  |

**7. `}` (두 번째 블록 종료) 및 `;` (연쇄 종료):**

- 🌟기준 위치가 다시 `[d3]`로 복원되고, 연쇄가 끝납니다.
    
    
    |  |  |  | 🔵 |  |  |  |  |
    | --- | --- | --- | --- | --- | --- | --- | --- |
    |  |  |  | 🔵 |  |  |  |  |
    |  |  |  | 🔵 |  |  |  |  |
    |  |  |  | 🔵 | 🔵 | 🔵 | 🔵 | 🔵 |
    |  |  | ♟️ |  |  |  |  |  |

---

### Tempest-Rook 행마 요약

`{ }` 블록의 기준 위치 복원 기능으로 이 기물의 행마는 다음과 같이 정의됩니다.

- **1단계:** 대각선으로 1칸 이동합니다.
- **2단계:** 그 1칸 이동한 위치에서, 동시에 2개의 룩(Rook) 슬라이드가 "발사"됩니다.
    - `take-move(1, 1)` (북동) 후: ➡️ (동쪽) 빔과 ⬆️ (북쪽) 빔 발사.
    - `take-move(-1, 1)` (북서) 후: ⬅️ (서쪽) 빔과 ⬆️ (북쪽) 빔 발사.
    - (그리고 남동, 남서 방향도 동일)

요약하면, 오른쪽 위로 한 칸 움직인 곳에서 룩의 오른쪽 행마와 위쪽 행마를 하는 행마법을 간결하게 표현한 것입니다.